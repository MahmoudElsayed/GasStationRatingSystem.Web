/**
* DevExpress Analytics (core\tools\_keyboardHelper.js)
* Version:  20.2.4
* Build date: Dec 2, 2020
* Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _internal_1 = require("../../serializer/_internal");
var KeyboardHelper = (function () {
    function KeyboardHelper(selection, undoEngine) {
        var _this = this;
        this._selection = selection;
        this._undoEngine = undoEngine;
        this.shortcutMap = {
            27: function (e) { _this.processEsc(); return true; },
            37: function (e) { _this.moveSelectedControls(true, true, -1); return true; },
            38: function (e) { _this.moveSelectedControls(true, false, -1); return true; },
            39: function (e) { _this.moveSelectedControls(false, true, 1); return true; },
            40: function (e) { _this.moveSelectedControls(false, false, 1); return true; },
        };
    }
    KeyboardHelper.prototype.processShortcut = function (e) {
        var method = this.shortcutMap[e.keyCode];
        if (method) {
            return method(e);
        }
        return false;
    };
    KeyboardHelper.prototype.processEsc = function () {
        var parent = this._selection.focused() && this._selection.focused().parent;
        parent && this._selection.focused(parent);
    };
    KeyboardHelper.prototype.moveSelectedControls = function (leftUp, isHoriz, sign) {
        var focusedControl = this._selection.focused();
        if (!focusedControl || focusedControl && focusedControl.getControlModel().getMetaData().isCopyDeny) {
            return;
        }
        this._undoEngine && this._undoEngine().start();
        var distance = 1, axisProperty = isHoriz ? 'left' : 'top', lengthProperty = isHoriz ? 'width' : 'height', minAxis, maxSide, newAxis;
        if (focusedControl.rect) {
            minAxis = focusedControl.rect()[axisProperty];
            maxSide = focusedControl.rect()[axisProperty] + focusedControl.rect()[lengthProperty];
        }
        else {
            return;
        }
        this._selection.selectedItems.filter(function (item) { return !item.locked; }).forEach(function (item) {
            var axis = item.rect()[axisProperty];
            if (axis < minAxis) {
                minAxis = axis;
            }
        });
        this._selection.selectedItems.filter(function (item) { return !item.locked; }).forEach(function (item) {
            var side = item.rect()[axisProperty] + item.rect()[lengthProperty];
            if (side > maxSide) {
                maxSide = side;
            }
        });
        if ((leftUp && minAxis <= 0) || (!focusedControl.parent.rect || (!leftUp && maxSide.toFixed(5) >= focusedControl.parent.rect()[lengthProperty]))) {
            return;
        }
        else {
            this._selection.selectedItems.filter(function (item) { return !item.locked; })
                .filter(function (item) { return !!item.rect; })
                .forEach(function (item) {
                var newVal = {}, itemAxisProperty = item.rect()[axisProperty], itemLengthProperty = item.rect()[lengthProperty], parentLengthProperty = item.parent.rect()[lengthProperty];
                newAxis = itemAxisProperty + sign * distance;
                if ((leftUp && newAxis >= 0) || (!leftUp && (newAxis + itemLengthProperty) <= parentLengthProperty)) {
                    newVal[axisProperty] = newAxis;
                }
                if (!leftUp && (newAxis + itemLengthProperty) > parentLengthProperty) {
                    newVal[axisProperty] = parentLengthProperty - itemLengthProperty;
                }
                if (leftUp && newAxis < 0 && itemAxisProperty > 0) {
                    newVal[axisProperty] = 0;
                }
                item.rect(newVal);
            });
        }
        this._undoEngine && this._undoEngine().end();
    };
    return KeyboardHelper;
}());
exports.KeyboardHelper = KeyboardHelper;
var KeyDownHandlersManager = (function () {
    function KeyDownHandlersManager(targetElement) {
        this._handlers = [];
        this._targetElement = targetElement;
    }
    Object.defineProperty(KeyDownHandlersManager.prototype, "_activeHandler", {
        get: function () {
            return this._handlers.length > 0 ? this._handlers[this._handlers.length - 1] : null;
        },
        enumerable: true,
        configurable: true
    });
    KeyDownHandlersManager.prototype._removeHandler = function (handler) {
        var index = this._handlers.indexOf(handler);
        if (index < 0)
            return;
        this._handlers.splice(index, 1);
        if (index === this._handlers.length) {
            this._targetElement.off('keydown', handler);
            if (this._activeHandler)
                this._targetElement.on('keydown', this._activeHandler);
        }
    };
    KeyDownHandlersManager.prototype.bindHandler = function (element, handler) {
        var _this = this;
        if (this._activeHandler)
            this._targetElement.off('keydown', this._activeHandler);
        this._handlers.push(handler);
        this._targetElement.on('keydown', handler);
        _internal_1.addDisposeCallback(element, function () { _this._removeHandler(handler); });
    };
    return KeyDownHandlersManager;
}());
exports.KeyDownHandlersManager = KeyDownHandlersManager;
